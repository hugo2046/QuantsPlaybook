# 股票网络中心度因子使用指南

**版本**: 1.0.0
**更新日期**: 2025-12-24
**作者**: Hugo

## 目录

1. [快速开始](#快速开始)
2. [核心算法详解](#核心算法详解)
3. [因子生成器使用](#因子生成器使用)
4. [完整工作流示例](#完整工作流示例)
5. [高级用法](#高级用法)
6. [最佳实践](#最佳实践)
7. [常见问题](#常见问题)
8. [API参考](#api参考)

---

## 快速开始

### 5分钟上手示例

```python
from src.generator import NetworkCentralityFactor

# 1. 初始化因子生成器
factor_engine = NetworkCentralityFactor(
    codes="csi300",              # 沪深300成分股
    start_date="2020-01-01",
    end_date="2023-12-31"
)

# 2. 获取数据
factor_engine.fetch_data()

# 3. 计算因子（一键获取所有因子）
factors = factor_engine.calculate_factors_separately(
    factor_types=['scc', 'tcc', 'cc'],
    window=20
)

# 4. 查看结果
print(f"SCC因子形状: {factors['scc'].shape}")
print(f"TCC因子形状: {factors['tcc'].shape}")
print(f"CC因子形状: {factors['cc'].shape}")

# 5. 清理内存
factor_engine.cleanup_memory()
```

### 运行结果

```
SCC因子形状: (972, 300)  # 972个交易日，300只股票
TCC因子形状: (972, 300)
CC因子形状: (972, 300)
```

---

## 核心算法详解

### 1. SCC因子（空间网络中心度）

#### 原理

SCC因子基于股票间Pearson相关系数的平均距离，反映股票在网络中的中心程度。

**计算公式**：
```
SCC_i = 1 / [2 * (1 - ρ̄_i)]
```

其中 `ρ̄_i` 是股票i与其他所有股票的平均相关系数。

**业务含义**：
- SCC值大：股票与市场中其他股票的相关性强，处于网络中心位置
- SCC值小：股票相对独立，与其他股票相关性弱，处于网络边缘

#### 直接使用核心算法

```python
import numpy as np
from src.factor_algo import calculate_scc

# 准备收益率数据：20天，100只股票
np.random.seed(42)
returns = np.random.randn(20, 100) * 0.02  # shape: (20, 100)

# 计算SCC因子
scc_values = calculate_scc(returns)

print(f"SCC因子值: {scc_values.shape}")  # (100,)
print(f"SCC因子范围: [{scc_values.min():.4f}, {scc_values.max():.4f}]")
```

#### 论文回测结果（全市场）

- IC均值：8.30%
- IC_IR：3.97
- 多空组合年化收益：26.80%
- 最大回撤：-1.79%

### 2. TCC因子（时间网络中心度）

#### 原理

TCC因子基于收益率偏离的时间稳定性，反映股票收益率随时间的波动程度。

**计算公式**：
```
TCC_i = 1 / E[z²]
```

其中 `z` 是收益率相对市场平均的标准化偏离度，`E[z²]` 是时间维度上的平均平方偏离。

**业务含义**：
- TCC值大：股票收益率相对市场平均的偏离小，波动稳定
- TCC值小：股票收益率波动大，与市场平均偏离度高

#### 直接使用核心算法

```python
import numpy as np
from src.factor_algo import calculate_tcc

# 准备收益率数据：20天，100只股票
np.random.seed(42)
returns = np.random.randn(20, 100) * 0.02  # shape: (20, 100)

# 计算TCC因子
tcc_values = calculate_tcc(returns)

print(f"TCC因子值: {tcc_values.shape}")  # (100,)
print(f"TCC因子范围: [{tcc_values.min():.4f}, {tcc_values.max():.4f}]")
```

#### 论文回测结果（全市场）

- IC均值：9.05%
- IC_IR：3.55
- 多空组合年化收益：22.10%
- 最大回撤：-15.02%

### 3. CC因子（综合网络中心度）

#### 原理

CC因子是SCC和TCC因子的1:1加权合成，综合考虑空间和时间维度的网络中心度。

**计算公式**：
```
CC_i = SCC_i * 0.5 + TCC_i * 0.5
```

**业务含义**：
- CC值大：股票在网络中位置中心且收益稳定
- CC值小：股票在网络中位置边缘或收益不稳定

#### 论文回测结果（全市场）

- IC均值：9.21%
- IC_IR：4.19
- 多空组合年化收益：24.86%
- 最大回撤：-7.95%

---

## 因子生成器使用

### NetworkCentralityFactor 类

`NetworkCentralityFactor` 是一个统一的因子生成接口，封装了数据获取、因子计算、批量处理和内存管理等完整流程。

#### 初始化

```python
from src.generator import NetworkCentralityFactor

# 使用预设股票池
factor_engine = NetworkCentralityFactor(
    codes="csi300",              # 或 "csi500", "ashares"
    start_date="2020-01-01",
    end_date="2023-12-31"
)

# 使用自定义股票池
factor_engine = NetworkCentralityFactor(
    codes=['000001.SZ', '600000.SH', '000002.SZ'],
    start_date="2020-01-01",
    end_date="2023-12-31"
)
```

**支持的股票池**：
- `"csi300"`: 沪深300成分股
- `"csi500"`: 中证500成分股
- `"ashares"`: 全A股
- 股票代码列表：如 `['000001.SZ', '600000.SH']`

#### 数据获取

```python
# 获取默认收益率数据（使用 $close/$preclose-1）
returns_df = factor_engine.fetch_data()

# 使用自定义字段
returns_df = factor_engine.fetch_data(
    fields=["$close"]  # 获取收盘价
)

# 查看数据
print(f"数据形状: {returns_df.shape}")
print(f"时间范围: {returns_df.index[0]} 至 {returns_df.index[-1]}")
print(f"股票数量: {len(returns_df.columns)}")
```

#### 单独计算因子

```python
# 计算SCC因子
scc_df = factor_engine.get_scc_factor(
    window=20,              # 20天滑动窗口
    ignore_errors=True,     # 忽略单个窗口错误
    show_progress=True,     # 显示进度条
    use_cache=True          # 使用缓存
)

# 计算TCC因子
tcc_df = factor_engine.get_tcc_factor(window=20)

# 计算CC因子
cc_df = factor_engine.get_cc_factor(window=20)
```

**参数说明**：

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| window | int | 20 | 滑动窗口大小（交易日） |
| ignore_errors | bool | True | 是否忽略单个窗口错误 |
| show_progress | bool | True | 是否显示tqdm进度条 |
| use_cache | bool | True | 是否使用缓存 |

#### 批量计算因子

```python
# 计算所有因子
factors = factor_engine.calculate_factors_separately(
    factor_types=['scc', 'tcc', 'cc'],
    window=20
)

# 访问结果
scc_df = factors['scc']
tcc_df = factors['tcc']
cc_df = factors['cc']

# 只计算SCC和TCC
factors = factor_engine.calculate_factors_separately(
    factor_types=['scc', 'tcc'],
    window=20
)
```

#### 内存管理

```python
# 只清理因子缓存
factor_engine.cleanup_memory(clear_data=False, clear_cache=True)

# 清理所有（包括数据）
factor_engine.cleanup_memory(clear_data=True, clear_cache=True)

# 计算完成后清理
factors = factor_engine.calculate_factors_separately()
factor_engine.cleanup_memory()  # 默认只清理缓存
```

---

## 完整工作流示例

### 示例1：沪深300因子计算

```python
from src.generator import NetworkCentralityFactor

# 1. 初始化
factor_engine = NetworkCentralityFactor(
    codes="csi300",
    start_date="2020-01-01",
    end_date="2023-12-31"
)

# 2. 获取数据
returns = factor_engine.fetch_data()
print(f"收益率数据: {returns.shape}")

# 3. 计算所有因子
factors = factor_engine.calculate_factors_separately(
    factor_types=['scc', 'tcc', 'cc'],
    window=20
)

# 4. 保存结果
factors['scc'].to_csv('data/scc_factor_csi300.csv')
factors['tcc'].to_csv('data/tcc_factor_csi300.csv')
factors['cc'].to_csv('data/cc_factor_csi300.csv')

# 5. 清理内存
factor_engine.cleanup_memory()

print("因子计算完成！")
```

### 示例2：多窗口因子计算

```python
from src.generator import NetworkCentralityFactor

factor_engine = NetworkCentralityFactor(
    codes="csi500",
    start_date="2020-01-01",
    end_date="2023-12-31"
)
factor_engine.fetch_data()

# 计算不同窗口的SCC因子
windows = [20, 40, 60, 120]
scc_factors = {}

for window in windows:
    print(f"计算 {window} 天窗口的SCC因子...")
    scc_factors[window] = factor_engine.get_scc_factor(window=window)
    print(f"完成！形状: {scc_factors[window].shape}")

# 比较不同窗口的因子分布
for window, scc_df in scc_factors.items():
    print(f"{window}天窗口 - 均值: {scc_df.mean().mean():.4f}, 标准差: {scc_df.std().mean():.4f}")

factor_engine.cleanup_memory()
```

### 示例3：自定义收益率计算

```python
from src.generator import NetworkCentralityFactor

factor_engine = NetworkCentralityFactor(
    codes="ashares",
    start_date="2020-01-01",
    end_date="2020-12-31"  # 1年数据
)

# 获取收盘价数据
close_prices = factor_engine.fetch_data(fields=["$close"])

# 手动计算收益率
import pandas as pd
returns = close_prices.pct_change().dropna()
factor_engine.returns_df = returns  # 设置收益率数据

# 计算因子
factors = factor_engine.calculate_factors_separately(window=20)
```

### 示例4：因子分析

```python
from src.generator import NetworkCentralityFactor
import matplotlib.pyplot as plt

factor_engine = NetworkCentralityFactor(
    codes="csi300",
    start_date="2020-01-01",
    end_date="2023-12-31"
)
factor_engine.fetch_data()

# 计算因子
factors = factor_engine.calculate_factors_separately(window=20)

# 分析SCC因子
scc_df = factors['scc']

# 1. 统计描述
print("SCC因子统计描述:")
print(scc_df.describe())

# 2. 因子分布（取某一天）
import matplotlib.pyplot as plt
scc_sample = scc_df.iloc[-1]  # 最后一天
plt.figure(figsize=(10, 6))
plt.hist(scc_sample.dropna(), bins=50, edgecolor='black')
plt.title('SCC因子分布（最后一天）')
plt.xlabel('SCC因子值')
plt.ylabel('股票数量')
plt.savefig('docs/images/scc_distribution.png')
plt.show()

# 3. 因子时间序列（取某只股票）
stock_id = scc_df.columns[0]
plt.figure(figsize=(12, 6))
plt.plot(scc_df.index, scc_df[stock_id])
plt.title(f'{stock_id} SCC因子时间序列')
plt.xlabel('日期')
plt.ylabel('SCC因子值')
plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig('docs/images/scc_timeseries.png')
plt.show()

factor_engine.cleanup_memory()
```

---

## 高级用法

### 1. 使用核心算法函数

```python
import pandas as pd
import numpy as np
from src.factor_algo import calculate_scc, calculate_tcc, generate_factor

# 准备数据
np.random.seed(42)
dates = pd.date_range('2020-01-01', periods=100, freq='D')
stocks = [f'stock_{i:03d}' for i in range(50)]
returns = pd.DataFrame(
    np.random.randn(100, 50) * 0.02,
    index=dates,
    columns=stocks
)

# 方法1：直接计算单个窗口
window_data = returns.iloc[:20].values  # 取前20天
scc_single = calculate_scc(window_data)
tcc_single = calculate_tcc(window_data)

print(f"单个窗口SCC: {scc_single.shape}")
print(f"单个窗口TCC: {tcc_single.shape}")

# 方法2：使用滑动窗口生成因子时间序列
scc_timeseries = generate_factor(
    returns,
    calculate_scc,
    window=20,
    show_progress=True
)

print(f"时间序列SCC: {scc_timeseries.shape}")
```

### 2. 自定义因子函数

```python
import numpy as np
from src.factor_algo import generate_factor
import pandas as pd

# 定义自定义因子函数
def calculate_volatility_factor(arr: np.ndarray) -> np.ndarray:
    """
    自定义因子：波动率的倒数

    Parameters
    ----------
    arr : np.ndarray
        收益率矩阵，shape为 (window, N)

    Returns
    -------
    np.ndarray
        波动率倒数因子，shape为 (N,)
    """
    # 计算每只股票的波动率（标准差）
    volatility = np.std(arr, axis=0)

    # 返回波动率的倒数（波动率越小，因子值越大）
    return 1 / volatility

# 使用自定义因子
np.random.seed(42)
dates = pd.date_range('2020-01-01', periods=100, freq='D')
stocks = [f'stock_{i:03d}' for i in range(50)]
returns = pd.DataFrame(
    np.random.randn(100, 50) * 0.02,
    index=dates,
    columns=stocks
)

# 计算自定义因子
custom_factor = generate_factor(
    returns,
    calculate_volatility_factor,
    window=20,
    show_progress=True
)

print(f"自定义因子形状: {custom_factor.shape}")
print(custom_factor.head())
```

### 3. 错误处理和容错

```python
from src.generator import NetworkCentralityFactor

factor_engine = NetworkCentralityFactor(
    codes="csi300",
    start_date="2020-01-01",
    end_date="2023-12-31"
)
factor_engine.fetch_data()

# 严格模式：任何窗口失败都停止
try:
    scc_strict = factor_engine.get_scc_factor(
        window=20,
        ignore_errors=False  # 遇到错误立即停止
    )
except Exception as e:
    print(f"计算失败: {e}")

# 容错模式：跳过错误窗口
scc_tolerance = factor_engine.get_scc_factor(
    window=20,
    ignore_errors=True  # 跳过错误窗口，继续处理
)

print(f"容错模式计算完成: {scc_tolerance.shape}")
```

### 4. 批量计算不同股票池

```python
from src.generator import NetworkCentralityFactor

# 定义多个股票池
pools = {
    '沪深300': 'csi300',
    '中证500': 'csi500'
}

results = {}

for pool_name, pool_codes in pools.items():
    print(f"\n处理 {pool_name}...")

    factor_engine = NetworkCentralityFactor(
        codes=pool_codes,
        start_date="2020-01-01",
        end_date="2023-12-31"
    )

    factor_engine.fetch_data()

    # 计算因子
    factors = factor_engine.calculate_factors_separately(
        factor_types=['scc', 'tcc', 'cc'],
        window=20
    )

    results[pool_name] = factors

    # 清理内存
    factor_engine.cleanup_memory()

    print(f"{pool_name} 完成！SCC形状: {factors['scc'].shape}")

# 比较不同股票池的因子
for pool_name, factors in results.items():
    scc_mean = factors['scc'].mean().mean()
    tcc_mean = factors['tcc'].mean().mean()
    cc_mean = factors['cc'].mean().mean()
    print(f"{pool_name}: SCC={scc_mean:.4f}, TCC={tcc_mean:.4f}, CC={cc_mean:.4f}")
```

---

## 最佳实践

### 1. 内存管理

**建议**：
- 计算完成后及时清理缓存
- 大规模数据（全市场）使用时，分批计算
- 使用 `use_cache=True` 避免重复计算

**示例**：
```python
factor_engine = NetworkCentralityFactor(
    codes="ashares",  # 全市场
    start_date="2020-01-01",
    end_date="2020-12-31"  # 先用1年数据测试
)

factor_engine.fetch_data()
factors = factor_engine.calculate_factors_separately()

# 使用完毕后立即清理
factor_engine.cleanup_memory(clear_cache=True)
```

### 2. 窗口选择

**常用窗口大小**：
- 20天：约1个月，适合短期因子
- 60天：约1季度，适合中期因子
- 120天：约半年，适合中长期因子
- 252天：1年，适合长期因子

**选择建议**：
```python
# 根据投资周期选择窗口
windows = {
    '短期': 20,
    '中期': 60,
    '长期': 120
}

for period, window in windows.items():
    scc = factor_engine.get_scc_factor(window=window)
    print(f"{period}窗口（{window}天）：均值={scc.mean().mean():.4f}")
```

### 3. 数据质量控制

```python
# 检查数据质量
returns = factor_engine.fetch_data()

# 1. 检查缺失值
missing_ratio = returns.isnull().sum() / len(returns)
print("缺失值比例:")
print(missing_ratio.describe())

# 2. 过滤缺失值过多的股票
valid_stocks = missing_ratio[missing_ratio < 0.1].index  # 缺失值<10%
returns_clean = returns[valid_stocks]

# 更新数据
factor_engine.returns_df = returns_clean

# 3. 计算因子
factors = factor_engine.calculate_factors_separately()
```

### 4. 因子标准化

```python
# Z-score标准化
def standardize_factor(df):
    """Z-score标准化"""
    return (df - df.mean()) / df.std()

# 计算因子
factors = factor_engine.calculate_factors_separately()

# 标准化
scc_std = standardize_factor(factors['scc'])
tcc_std = standardize_factor(factors['tcc'])
cc_std = standardize_factor(factors['cc'])

# 验证标准化结果
print(f"SCC标准化后: 均值={scc_std.mean().mean():.6f}, 标准差={scc_std.std().mean():.6f}")
```

### 5. 性能优化

**建议**：
- 使用批量计算而非逐个调用
- 开启缓存避免重复计算
- 合理选择窗口大小

**示例**：
```python
# 推荐：批量计算
factors = factor_engine.calculate_factors_separately(
    factor_types=['scc', 'tcc', 'cc'],
    window=20,
    use_cache=True  # 开启缓存
)

# 不推荐：逐个计算（重复获取数据）
scc = factor_engine.get_scc_factor(window=20)
# ... 中间可能做其他操作
tcc = factor_engine.get_tcc_factor(window=20)
cc = factor_engine.get_cc_factor(window=20)
```

---

## 常见问题

### Q1: 如何选择股票池？

**A**: 根据研究目标和计算资源选择：

- **测试/学习**：使用 `csi300`（300只股票，计算快速）
- **实战应用**：使用 `csi500` 或 `ashares`
- **自定义股票池**：根据策略需求选择特定股票

```python
# 学习测试
factor_engine = NetworkCentralityFactor(codes="csi300", ...)

# 实战应用
factor_engine = NetworkCentralityFactor(codes="ashares", ...)
```

### Q2: 窗口大小如何选择？

**A**: 根据投资周期和数据量选择：

```python
# 短线交易（1个月）
window = 20

# 中线投资（1季度）
window = 60

# 长线投资（半年到1年）
window = 120 or 252
```

### Q3: 数据格式要求是什么？

**A**: 收益率数据需要是 DataFrame 格式：
- index: DatetimeIndex（日期）
- columns: 股票代码
- values: 收益率数值

```python
# 正确格式
                股票A    股票B    股票C
2020-01-01      0.02    0.01    -0.01
2020-01-02      -0.01   0.03     0.02
...
```

### Q4: 如何处理缺失值？

**A**: 有两种方式：

1. **在数据预处理阶段处理**：
```python
returns = factor_engine.fetch_data()
returns_clean = returns.fillna(0)  # 或 dropna()
factor_engine.returns_df = returns_clean
```

2. **依赖因子计算的容错机制**：
```python
# 使用 ignore_errors=True
scc = factor_engine.get_scc_factor(
    window=20,
    ignore_errors=True  # 跳过错误窗口
)
```

### Q5: 如何保存和加载因子？

**A**: 使用 pandas 的保存功能：

```python
# 保存因子
factors = factor_engine.calculate_factors_separately()
factors['scc'].to_csv('scc_factor.csv')
factors['tcc'].to_csv('tcc_factor.csv')
factors['cc'].to_csv('cc_factor.csv')

# 加载因子
import pandas as pd
scc_loaded = pd.read_csv('scc_factor.csv', index_col=0, parse_dates=True)
```

### Q6: 内存不足怎么办？

**A**: 使用以下策略：

1. **减少数据量**：
```python
# 使用更短的日期范围
factor_engine = NetworkCentralityFactor(
    codes="ashares",
    start_date="2023-01-01",  # 只用1年
    end_date="2023-12-31"
)
```

2. **及时清理内存**：
```python
factors = factor_engine.calculate_factors_separately()
factor_engine.cleanup_memory(clear_data=True, clear_cache=True)
```

3. **分批计算**：
```python
# 分年份计算
for year in range(2020, 2024):
    factor_engine = NetworkCentralityFactor(
        codes="ashares",
        start_date=f"{year}-01-01",
        end_date=f"{year}-12-31"
    )
    factor_engine.fetch_data()
    factors = factor_engine.calculate_factors_separately()
    # 保存结果
    factors['scc'].to_csv(f'scc_factor_{year}.csv')
    factor_engine.cleanup_memory()
```

---

## API参考

### NetworkCentralityFactor 类

#### 初始化

```python
NetworkCentralityFactor(codes, start_date, end_date)
```

**参数**：
- `codes` (str or list): 股票池
- `start_date` (str): 开始日期 "YYYY-MM-DD"
- `end_date` (str): 结束日期 "YYYY-MM-DD"

#### 方法

##### fetch_data()

```python
fetch_data(fields=None)
```

获取收益率数据。

**参数**：
- `fields` (list, optional): Qlib字段表达式，默认 ["$close/$preclose-1"]

**返回**：
- `pd.DataFrame`: 收益率数据

##### get_scc_factor()

```python
get_scc_factor(window=20, ignore_errors=True, show_progress=True, use_cache=True)
```

计算SCC因子。

**参数**：
- `window` (int): 滑动窗口大小
- `ignore_errors` (bool): 是否忽略错误
- `show_progress` (bool): 是否显示进度条
- `use_cache` (bool): 是否使用缓存

**返回**：
- `pd.DataFrame`: SCC因子数据

##### get_tcc_factor()

```python
get_tcc_factor(window=20, ignore_errors=True, show_progress=True, use_cache=True)
```

计算TCC因子。

**参数**：同 `get_scc_factor()`

**返回**：
- `pd.DataFrame`: TCC因子数据

##### get_cc_factor()

```python
get_cc_factor(window=20, ignore_errors=True, show_progress=True, use_cache=True)
```

计算CC因子（SCC和TCC的1:1合成）。

**参数**：同 `get_scc_factor()`

**返回**：
- `pd.DataFrame`: CC因子数据

##### calculate_factors_separately()

```python
calculate_factors_separately(factor_types=['scc', 'tcc', 'cc'], window=20, ...)
```

批量计算多个因子。

**参数**：
- `factor_types` (list): 因子类型列表，可选 'scc', 'tcc', 'cc'
- `window` (int): 滑动窗口大小
- 其他参数同上

**返回**：
- `dict`: 因子字典 `{'scc': DataFrame, 'tcc': DataFrame, 'cc': DataFrame}`

##### cleanup_memory()

```python
cleanup_memory(clear_data=False, clear_cache=True)
```

清理内存缓存。

**参数**：
- `clear_data` (bool): 是否清理收益率数据
- `clear_cache` (bool): 是否清理因子缓存

### 核心算法函数

#### calculate_scc()

```python
calculate_scc(arr: np.ndarray) -> np.ndarray
```

计算空间网络中心度因子。

**参数**：
- `arr` (np.ndarray): 收益率矩阵，shape为 (window, N)

**返回**：
- `np.ndarray`: SCC因子值数组，shape为 (N,)

#### calculate_tcc()

```python
calculate_tcc(arr: np.ndarray) -> np.ndarray
```

计算时间网络中心度因子。

**参数**：
- `arr` (np.ndarray): 收益率矩阵，shape为 (window, N)

**返回**：
- `np.ndarray`: TCC因子值数组，shape为 (N,)

#### generate_factor()

```python
generate_factor(returns, func, window=20, ignore_errors=True, show_progress=True)
```

使用滑动窗口生成因子时间序列。

**参数**：
- `returns` (pd.DataFrame): 收益率数据框
- `func` (Callable): 因子计算函数
- `window` (int): 滑动窗口大小
- `ignore_errors` (bool): 是否忽略错误
- `show_progress` (bool): 是否显示进度条

**返回**：
- `pd.DataFrame`: 因子值数据框

---

## 参考资料

1. **研究论文**：华西证券金融工程专题报告（2021年3月）《股票网络与网络中心度因子研究》
2. **项目文档**：
   - [CLAUDE.md](../CLAUDE.md) - 项目技术文档
   - [README.md](../README.md) - 项目说明
3. **核心代码**：
   - [src/factor_algo.py](../src/factor_algo.py) - 核心算法
   - [src/generator.py](../src/generator.py) - 因子生成器

---

**文档版本**: 1.0.0
**最后更新**: 2025-12-24
**维护者**: Hugo
